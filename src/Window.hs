{-# LANGUAGE FlexibleContexts #-}
module Window (
  Positional(..),
  Window(..),
  slidingWindow,
  initWindow,
  HasPosition
  ) where

import Data

import Control.Monad.Trans        (lift)
import Control.Monad.State        (StateT, get, modify, put)
import Control.Monad.Trans.Except (ExceptT, throwE)
import Control.Monad.Reader       (ReaderT, asks, mapReaderT)
import Data.Function              (on)
import Data.Sequence              (Seq, (|>), dropWhileL)


type SlidingWindow m p a = StateT (Window a (p a)) (ReaderT InterfaceOptions m) [(Window a (p a))]

{- Main functions -}
slidingWindow :: (Monad m, HasPosition p Int) =>
                  [p Int] ->
                  SlidingWindow m p Int
slidingWindow []       = get >>= return . return
slidingWindow l@(x:xs) = do
  window <- get
  case coverage (start window) (end window) (position x) of
    Above    -> slidingWindow xs      -- Continue with next input

    Overlap  -> do                    -- Append x to window and continue with next input
      modify (\st -> st{values = values window |> x})
      slidingWindow xs
      
    Under    -> do                    -- Move the window with one step
      stepWindow                      -- and return the previous window followed by 
      rest <- slidingWindow l         -- windows generated by from the current input
      return (window:rest)

stepWindow :: (Monad m, HasPosition p Int) =>
              StateT (Window Int (p Int)) (ReaderT InterfaceOptions m) ()
stepWindow = do
  step           <- lift $ asks wStep
  (Window s e v) <- get
  let s' = s + step
      e' = e + step
      v' = dropWhileL (onP (s' >)) v
  put $ Window s' e' v'


coverage :: Ord a => a -> a -> a -> Coverage  
coverage l u x = case l `compare` x of
  LT -> if u >= x
        then Overlap
        else Under
  EQ -> Overlap
  _  -> Above

initWindow :: (Monad m) => ReaderT InterfaceOptions m (Window Int a)
initWindow = asks wSize >>= \x -> (return $ Window 1 x mempty)


checkListP :: (Monad m, HasPosition p a) =>
                 e ->
                 (a -> a -> Bool) ->
                 [p a] ->
                 [ExceptT e m (p a)]
checkListP _ _ []          = []
checkListP _ _ (x:[])      = [pure x]
checkListP e f l@(x1:x2:_) = x : go
  where
    go = checkListP e f $ tail l
    x  | onP2 f x1 x2 = pure x1
       | otherwise    = throwE e
