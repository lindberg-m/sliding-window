{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
module Window (
  Positional(..),
  Window(..),
  slidingWindow,
  initWindow,
  HasPosition
  ) where

import Control.Monad.State        (StateT, get, modify)
import Control.Monad.Trans.Except (ExceptT, throwE)
import Data.Function              (on)
import Data.Sequence              (Seq, (|>), dropWhileL)

-- Data Definitions
data Positional a b = Positional {val :: a, pos :: b}

data Window a b = Window { start  :: a,
                           end    :: a,
                           values :: Seq b }
    deriving (Eq, Show)

data Coverage = Under
              | Overlap
              | Above 
   deriving (Eq, Show)

  
{- Main functions -}
slidingWindow :: (Num a, Monad m, HasPosition p a) =>
                  a ->
                  [p a] ->
                  StateT (Window a (p a)) m [(Window a (p a))]
slidingWindow _ []          = get >>= return . return
slidingWindow step l@(x:xs) = do
  window <- get
  {- Make a decision based on wether or not
     the position of the window covers the
     current position of the input -}
  case coverage (start window) (end window) (position x) of
    Above    -> slidingWindow step xs -- Continue with next input

    Overlap  -> do                    -- Append x to window and continue with next input
      modify (\st -> st{values = values window |> x})
      slidingWindow step xs
      
    Under    -> do                    -- Move the window with one step
      modify (stepWindow step)        -- and return the previous window followed by 
      rest <- slidingWindow step l    -- windows generated by from the current input
      return (window:rest)


stepWindow :: (Num a, HasPosition p a) => a -> Window a (p a) -> Window a (p a)
stepWindow x (Window s e v) = Window s' e' v'
    where
      s' = s + x
      e' = e + x
      v' = dropWhileL (onP (s' >)) v

coverage :: Ord a => a -> a -> a -> Coverage  
coverage l u x = case l `compare` x of
  LT -> if u >= x
        then Overlap
        else Under
  EQ -> Overlap
  _  -> Above

initWindow :: Num a => a -> Window a b
initWindow a = Window 1 a mempty

{- Class definition -}
class Ord a => HasPosition p a where
  {- MINIMAL position -}
  position  :: p a -> a
  compareP  :: p a -> p a -> Ordering
  onP       :: (a -> b) -> p a -> b
  onP2      :: (a -> a -> b) -> p a -> p a -> b

  onP f     = f . position
  onP2 f    = f `on` position
  compareP  = onP2 compare

checkListP :: (Monad m, HasPosition p a) =>
                 e ->
                 (a -> a -> Bool) ->
                 [p a] ->
                 [ExceptT e m (p a)]
checkListP _ _ []          = []
checkListP _ _ (x:[])      = [pure x]
checkListP e f l@(x1:x2:_) = x : go
  where
    go = checkListP e f $ tail l
    x  | onP2 f x1 x2 = pure x1
       | otherwise    = throwE e

-- Instances
instance (Eq a, Ord b) => Eq (Positional a b) where
  (Positional x y) == (Positional x' y') =
    x == x' && y == y'
instance (Show a, Show b) => Show (Positional a b) where
  show (Positional a b) = "Positional " ++ show a ++ ' ':show b
          
instance Ord x => HasPosition (Positional a) x where
  position = pos


