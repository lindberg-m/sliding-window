{-# LANGUAGE FlexibleContexts #-}
module Window (
  runSlidingWindow,
  slidingWindow,
  initWindow,
  checkListP
  ) where

import Data

import Control.Monad.Trans        (lift)
import Control.Monad.State        (StateT, evalStateT, get, modify, put)
import Control.Monad.Trans.Except (ExceptT, throwE)
import Control.Monad.Reader       (ReaderT, asks, ask, runReaderT)
import Data.Sequence              (Seq, (|>), dropWhileL)


type SlidingWindow m p a = StateT (Window a (p a)) (ReaderT a m) [(Window a (p a))]

{- Main functions -}
runSlidingWindow :: (Monad m, HasPosition p a, Num a) =>
                    Window a (p a) ->  -- inital state
                    a ->               -- step size
                    [p a] ->           -- input
                    m [Window a (p a)]
runSlidingWindow w s xs = runReaderT (evalStateT (slidingWindow xs) w) s


slidingWindow :: (Monad m, HasPosition p a, Num a) =>
                  [p a] ->
                  SlidingWindow m p a
slidingWindow []       = get >>= return . return
slidingWindow l@(x:xs) = do
  window <- get
  case coverage (start window) (end window) (position x) of
    Above    -> slidingWindow xs      -- Continue with next input

    Overlap  -> do                    -- Append x to window and continue with next input
      modify (\st -> st{values = values window |> x})
      slidingWindow xs
      
    Under    -> do                    -- Move the window with one step
      stepWindow                      -- and return the previous window followed by 
      rest <- slidingWindow l         -- windows generated by from the current input
      return (window:rest)

stepWindow :: (Monad m, HasPosition p a, Num a) =>
              StateT (Window a (p a)) (ReaderT a m) ()
stepWindow = do
  step           <- lift ask
  (Window s e v) <- get
  let s' = s + step
      e' = e + step
      v' = dropWhileL (onP (s' >)) v
  put $ Window s' e' v'


coverage :: Ord a => a -> a -> a -> Coverage  
coverage l u x = case l `compare` x of
  LT -> if u >= x
        then Overlap
        else Under
  EQ -> Overlap
  _  -> Above

initWindow :: (Monad m) => ReaderT InterfaceOptions m (Window Int a)
initWindow = asks wSize >>= \x -> (return $ Window 1 x mempty)

checkListP :: (Monad m, HasPosition p a) =>
                 e ->
                 (a -> a -> Bool) ->
                 [p a] ->
                 [ExceptT e m (p a)]
checkListP _ _ []          = []
checkListP _ _ (x:[])      = [pure x]
checkListP e f l@(x1:x2:_) = x : go
  where
    go = checkListP e f $ tail l
    x  | onP2 f x1 x2 = pure x1
       | otherwise    = throwE e
